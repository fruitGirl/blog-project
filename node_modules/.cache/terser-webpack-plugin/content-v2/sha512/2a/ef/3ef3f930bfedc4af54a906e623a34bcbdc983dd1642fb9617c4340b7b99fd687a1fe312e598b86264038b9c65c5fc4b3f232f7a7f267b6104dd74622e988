{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{430:function(n,e,t){\"use strict\";t.r(e);var s=t(2),a=Object(s.a)({},(function(){var n=this,e=n._self._c;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[e(\"blockquote\",[e(\"p\",[n._v(\"虽然发布订阅模式严格意义来讲不属于设计模式中的一种，但是在各大框架源码中，经常使用发布订阅模式。下面我们来看下怎么实现的吧。\")])]),n._v(\" \"),e(\"h4\",{attrs:{id:\"什么是发布订阅模式\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是发布订阅模式\"}},[n._v(\"#\")]),n._v(\" 什么是发布订阅模式？\")]),n._v(\" \"),e(\"p\",[n._v(\"发布订阅模式是一种对象间一对多的依赖关系，当一个对象的状态（发布者）发生改变时，所有依赖它的对象（订阅者）都将得到通知。\")]),n._v(\" \"),e(\"p\",[n._v(\"举个栗子\")]),n._v(\" \"),e(\"p\",[n._v(\"当我们在浏览博客论坛之类的网站时，遇到感兴趣的up主，我们会订阅他们的文章，这样一来，他们每次在网站发布一个文章，网站就会通知到我们他们发布了文章。我们便可以第一时间了解到，但是看与不看取决于我们自己。\")]),n._v(\" \"),e(\"p\",[n._v(\"上述就是一个简单的发布订阅模式。up主就是发布者，我们（用户）就是订阅者，然后网站就是调度中心。\")]),n._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8fdc557070b4d5ea1f26f8091dd9ca0~tplv-k3u1fbpfcp-watermark.image?\",alt:\"image.png\"}})]),n._v(\" \"),e(\"ul\",[e(\"li\",[e(\"code\",[n._v(\"发布者（Publisher）\")]),n._v(\"：发布者通过调度中心发布事件（也就是up主通过网站来发布文章）\")]),n._v(\" \"),e(\"li\",[e(\"code\",[n._v(\"订阅者（subscriber）\")]),n._v(\"：通过调度中心订阅事件（也就是我们通过网站来接收通知）\")]),n._v(\" \"),e(\"li\",[e(\"code\",[n._v(\"调用中心（Event Channel）\")]),n._v(\"：负责存放订阅者和事件的关系（也就是网站这个平台）\")])]),n._v(\" \"),e(\"h4\",{attrs:{id:\"如何实现一个简单的发布订阅模式\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何实现一个简单的发布订阅模式\"}},[n._v(\"#\")]),n._v(\" 如何实现一个简单的发布订阅模式？\")]),n._v(\" \"),e(\"p\",[n._v(\"我们先理一下整体的发布-订阅模式的思路：\")]),n._v(\" \"),e(\"ul\",[e(\"li\",[n._v(\"创建一个类\"),e(\"code\",[n._v(\"class\")])]),n._v(\" \"),e(\"li\",[n._v(\"在这个类里创建一个缓存列表（调度中心）\")]),n._v(\" \"),e(\"li\",[e(\"code\",[n._v(\"on\")]),n._v(\"方法：把\"),e(\"code\",[n._v(\"fn\")]),n._v(\"函数添加到缓存列表（订阅者注册事件到订阅中心）\")]),n._v(\" \"),e(\"li\",[e(\"code\",[n._v(\"emit\")]),n._v(\"方法：取到event事件类型（type），然后执行缓存列表下对应类型的函数（发布者发布事件到调度中心，调度中心处理代码）\")]),n._v(\" \"),e(\"li\",[e(\"code\",[n._v(\"off\")]),n._v(\"方法：可以根据event事件类型取消订阅（取消订阅）\")])]),n._v(\" \"),e(\"p\",[n._v(\"我们下面根据思路来实现\")]),n._v(\" \"),e(\"h4\",{attrs:{id:\"_1-创建一个eventemitter类\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-创建一个eventemitter类\"}},[n._v(\"#\")]),n._v(\" 1.创建一个EventEmitter类\")]),n._v(\" \"),e(\"p\",[n._v(\"我们先创建一个类，我们还需要一个构造函数如下：\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"class EventEmitter {\\n  constructor() {\\n    \\n  }\\n}\\n\")])])]),e(\"h4\",{attrs:{id:\"_2-添加on、emit、off方法\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-添加on、emit、off方法\"}},[n._v(\"#\")]),n._v(\" 2.添加on、emit、off方法\")]),n._v(\" \"),e(\"p\",[n._v(\"我们为了把这三个方法长的像\"),e(\"code\",[n._v(\"vue\")]),n._v(\"，每个方法前加一个$\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"class EventEmitter {\\n  constructor() {\\n\\n  }\\n  // 向消息队列添加内容\\n  $on() {\\n\\n  }\\n  // 出发消息队列的对应内容\\n  $emit() {\\n\\n  }\\n  // 删除消息队列的对应内容\\n  $off() {\\n\\n  }\\n}\\n\")])])]),e(\"p\",[n._v(\"我们先来创建一个订阅者\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"class EventEmitter {\\n  constructor() {\\n\\n  }\\n  // 向消息队列添加内容\\n  $on() {\\n\\n  }\\n  // 出发消息队列的对应内容\\n  $emit() {\\n\\n  }\\n  // 删除消息队列的对应内容\\n  $off() {\\n\\n  }\\n}\\n// 使用构造函数创建一个实例\\nconst person1 = new EventEmitter()\\n// 像这个person1委托一些内容\\nperson1.$on()\\n\")])])]),e(\"p\",[n._v(\"既然要委托一些内容，那\"),e(\"strong\",[n._v(\"事件名\")]),n._v(\"就必不可少，事件触发的时候还需要一个\"),e(\"strong\",[n._v(\"回调函数\")]),n._v(\"\\n所以需要两个参数：\")]),n._v(\" \"),e(\"ol\",[e(\"li\",[n._v(\"事件名\")]),n._v(\" \"),e(\"li\",[n._v(\"回调函数\")])]),n._v(\" \"),e(\"p\",[n._v(\"举个栗子\")]),n._v(\" \"),e(\"p\",[n._v(\"我们麻烦\"),e(\"code\",[n._v(\"person1\")]),n._v(\"监听下买手机，手机到了之后去执行回调函数\"),e(\"code\",[n._v(\"fn1\")]),n._v(\"和\"),e(\"code\",[n._v(\"fn2\")])]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"class EventEmitter {\\n  constructor() {\\n\\n  }\\n  // 向消息队列添加内容\\n  $on() {\\n\\n  }\\n  // 触发消息队列的对应内容\\n  $emit() {\\n\\n  }\\n  // 删除消息队列的对应内容\\n  $off() {\\n\\n  }\\n}\\n\\nfunction fn1() {\\n  console.log(\\\"我是函数fn1\\\")\\n}\\n\\nfunction fn2() {\\n  console.log(\\\"我是函数fn2\\\")\\n}\\n// 使用构造函数创建一个实例\\nconst person1 = new EventEmitter()\\n// 像这个person1委托一些内容,其中买手机是事件名，fn1和fn2是需要触发的回调函数\\nperson1.$on('buyPhone', fn1)\\nperson1.$on('buyPhone', fn2)\\n\")])])]),e(\"p\",[n._v(\"那我们怎么把这些事件存储起来呢，下面来看缓存列表（调度中心）\")]),n._v(\" \"),e(\"h4\",{attrs:{id:\"_3-缓存列表\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-缓存列表\"}},[n._v(\"#\")]),n._v(\" 3.缓存列表\")]),n._v(\" \"),e(\"p\",[n._v(\"缓存列表\"),e(\"code\",[n._v(\"message\")]),n._v(\"主要做什么：\\n向\"),e(\"code\",[n._v(\"person1\")]),n._v(\"委托一个买手机之后，随后调用\"),e(\"code\",[n._v(\"fn1\")]),n._v(\"和\"),e(\"code\",[n._v(\"fn2\")]),n._v(\"函数。\\n所以我们希望通过\"),e(\"code\",[n._v(\"$on\")]),n._v(\"来实现，给\"),e(\"code\",[n._v(\"message\")]),n._v(\"添加一个\"),e(\"code\",[n._v(\"buyPhone\")]),n._v(\"属性后，然后这个属性的值为\"),e(\"code\",[n._v(\"[fn1, fn2]\")]),n._v(\",如下\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"class EventEmitter {\\n  constructor() {\\n    this.message = {\\n    buyPhone: [fn1, fn2]\\n    } // 消息队列（缓存列表）\\n  }\\n  // 向消息队列添加内容\\n  $on() {\\n\\n  }\\n  // 触发消息队列的对应内容\\n  $emit() {\\n\\n  }\\n  // 删除消息队列的对应内容\\n  $off() {\\n\\n  }\\n}\\n\\nfunction fn1() {\\n  console.log(\\\"我是函数fn1\\\")\\n}\\n\\nfunction fn2() {\\n  console.log(\\\"我是函数fn2\\\")\\n}\\n// 使用构造函数创建一个实例\\nconst person1 = new EventEmitter()\\n// 像这个person1委托一些内容,其中买手机是事件名，fn1和fn2是需要触发的回调函数\\nperson1.$on('buyPhone', fn1)\\nperson1.$on('buyPhone', fn2)\\n\")])])]),e(\"p\",[n._v(\"那我们通过\"),e(\"code\",[n._v(\"$on\")]),n._v(\"怎么实现呢？\")]),n._v(\" \"),e(\"p\",[n._v(\"4.\"),e(\"code\",[n._v(\"$on\")]),n._v(\"方法的实现\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"person1.$on('buyPhone', fn1)\\n\")])])]),e(\"p\",[n._v(\"我们在确定下\"),e(\"code\",[n._v(\"$on\")]),n._v(\"方法的实现思路：\")]),n._v(\" \"),e(\"ul\",[e(\"li\",[n._v(\"我们首先需要两个参数，一个\"),e(\"code\",[n._v(\"type\")]),n._v(\"（事件名）， 一个\"),e(\"code\",[n._v(\"callback\")]),n._v(\"（回调函数）。\")]),n._v(\" \"),e(\"li\",[n._v(\"判断缓存队列里是否存在\"),e(\"code\",[n._v(\"type\")]),n._v(\"，如果不存在，就初始化一个空数组\")]),n._v(\" \"),e(\"li\",[n._v(\"把回调函数\"),e(\"code\",[n._v(\"push\")]),n._v(\"进缓存列表（调度中心）中（因为需要的回调函数可以是多个，所以是个数组）\\n下面我们来看下实现代码\")])]),n._v(\" \"),e(\"p\",[n._v(\"event.js\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v('class EventEmitter {\\n  constructor() {\\n    this.message = {} // 消息队列（缓存列表）\\n\\n  }\\n\\n  /** $on:向消息队列添加内容\\n   * @params {*} type:事件名\\n   * @params {*} callback:回调函数\\n   **/\\n  // \\n  $on(type, callback) {\\n    // 判断是否有事件类型这个属性\\n    if (!this.message[type]) {\\n      // 没有的话，初始化一个空数组\\n      this.message[type] = [];\\n    }\\n    // 把回调函数放入调度中心中\\n    this.message[type].push(callback)\\n  }\\n  // 触发消息队列的对应内容\\n  $emit() {\\n\\n  }\\n  // 删除消息队列的对应内容\\n  $off() {\\n\\n  }\\n}\\n\\nfunction fn1() {\\n  console.log(\"我是函数fn1\")\\n}\\n\\nfunction fn2() {\\n  console.log(\"我是函数fn2\")\\n}\\n// 使用构造函数创建一个实例\\nconst person1 = new EventEmitter()\\n// 像这个person1委托一些内容\\nperson1.$on(\\'buyPhone\\', fn1)\\nperson1.$on(\\'buyPhone\\', fn2)\\nconsole.log(\"person1====\", person1)\\n')])])]),e(\"p\",[n._v(\"我们加入一个html测试一下\")]),n._v(\" \"),e(\"p\",[n._v(\"demo.html\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- line-numbers-mode\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v('<!DOCTYPE html>\\n<html lang=\"en\">\\n  <head>\\n    <meta charset=\"UTF-8\" />\\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\\n    <title>Document</title>\\n  </head>\\n  <body>\\n   <script src=\"./event.js\"><\\/script>\\n  </body>\\n</html>\\n\\n')])]),n._v(\" \"),e(\"div\",{staticClass:\"line-numbers-wrapper\"},[e(\"span\",{staticClass:\"line-number\"},[n._v(\"1\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"2\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"3\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"4\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"5\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"6\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"7\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"8\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"9\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"10\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"11\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"12\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[n._v(\"13\")]),e(\"br\")])]),e(\"p\",[n._v(\"运行结果如下\")]),n._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75b019e91cad40309d1b1a96178bb823~tplv-k3u1fbpfcp-watermark.image?\",alt:\"image.png\"}})]),n._v(\" \"),e(\"p\",[n._v(\"打印出来的是\"),e(\"code\",[n._v(\"EventEmitter\")]),n._v(\"类，里面有个缓存列表，有个\"),e(\"code\",[n._v(\"buyPhone\")]),n._v(\"的属性，对应的值是\"),e(\"code\",[n._v(\"fn1\")]),n._v(\"和\"),e(\"code\",[n._v(\"fn2\")]),n._v(\"两个回调函数。说明测试通过了\")]),n._v(\" \"),e(\"p\",[n._v(\"5.$off方法\")]),n._v(\" \"),e(\"p\",[n._v(\"我们来看取消订阅的调用，可能会有两种：\")]),n._v(\" \"),e(\"ul\",[e(\"li\",[n._v(\"第一种\"),e(\"code\",[n._v('person1.$off(\"buyPhone\")')]),n._v(\":删除整个事件类型\")]),n._v(\" \"),e(\"li\",[n._v(\"第二种\"),e(\"code\",[n._v('person1.$off(\"buyPhone\", fn1)')]),n._v(\": 删除\"),e(\"code\",[n._v(\"fn1\")]),n._v(\"消息，缓存列表里面其他消息不动\")])]),n._v(\" \"),e(\"p\",[n._v(\"知道调用了，我们先来理一下思路\")]),n._v(\" \"),e(\"ul\",[e(\"li\",[n._v(\"首先我们有两个参数，一个\"),e(\"code\",[n._v(\"type\")]),n._v(\"（事件类型），一个\"),e(\"code\",[n._v(\"callback\")]),n._v(\"(回调函数）\")]),n._v(\" \"),e(\"li\",[n._v(\"判断是不是有\"),e(\"code\",[n._v(\"type\")]),n._v(\"属性，如果没有，直接\"),e(\"code\",[n._v(\"return\")]),n._v(\"掉\")]),n._v(\" \"),e(\"li\",[n._v(\"判断是不是有回调函数，如果没有回调函数，直接删除整个事件\")]),n._v(\" \"),e(\"li\",[n._v(\"最后删除取消订阅的消息\")])]),n._v(\" \"),e(\"p\",[n._v(\"实现代码如下\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"class EventEmitter {\\n  constructor() {\\n    this.message = {} // 消息队列（缓存列表）\\n\\n  }\\n\\n  /** $on:向消息队列添加内容\\n   * @params {*} type:事件名\\n   * @params {*} callback:回调函数\\n   **/\\n  $on(type, callback) {\\n    // 判断是否有事件类型这个属性\\n    if (!this.message[type]) {\\n      // 没有的话，初始化一个空数组\\n      this.message[type] = [];\\n    }\\n    // 把回调函数放入调度中心中\\n    this.message[type].push(callback)\\n  }\\n  // 触发消息队列的对应内容\\n  $emit() {\\n\\n  }\\n  /** $off:删除消息队列的对应内容\\n   * @params {*} type:事件名\\n   * @params {*} callback:回调函数\\n   **/\\n  $off(type, callback) {\\n    // 判断如果没有type这个事件类型，没有直接return\\n    if (!this.message[type]) return;\\n    // 判断有没有回调函数，没有直接删除整个事件\\n    if (!callback) {\\n      this.message[type] = undefined\\n    }\\n    // 如果有callback，就仅仅删除callback这个消息\\n    this.message[type] = this.message[type].filter(item => item !== callback)\\n\\n  }\\n}\\n\\nfunction fn1() {\\n  console.log(\\\"我是函数fn1\\\")\\n}\\n\\nfunction fn2() {\\n  console.log(\\\"我是函数fn2\\\")\\n}\\n// 使用构造函数创建一个实例\\nconst person1 = new EventEmitter()\\n// 像这个person1委托一些内容\\nperson1.$on('buyPhone', fn1)\\nperson1.$on('buyPhone', fn2)\\nperson1.$off('buyPhone', fn2)\\n\\nconsole.log(\\\"person1====\\\", person1)\\n\")])])]),e(\"p\",[n._v(\"我们再测试下，结果如下\")]),n._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be32ee2f925451a9a9ef5281518d13a~tplv-k3u1fbpfcp-watermark.image?\",alt:\"image.png\"}})]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"person1.$off('buyPhone')\\nconsole.log(\\\"person1====\\\", person1)\\n\")])])]),e(\"p\",[e(\"img\",{attrs:{src:\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e26c376ba5944b8ab39330c0cb6a174b~tplv-k3u1fbpfcp-watermark.image?\",alt:\"image.png\"}})]),n._v(\" \"),e(\"p\",[n._v(\"以上结果说明测试通过\")]),n._v(\" \"),e(\"blockquote\",[e(\"p\",[n._v(\"这里说一个题外话：为什么删除对象的属性用object.key=undefined而不用delete直接删除，这里就有一个性能优化的问题存在。如果有兴趣，我可以下一篇说下这两者之间的区别\")])]),n._v(\" \"),e(\"p\",[n._v(\"6.$emit方法\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v('person1.$emit(\"buyPhone\")\\n')])])]),e(\"p\",[n._v(\"思路如下：\")]),n._v(\" \"),e(\"ul\",[e(\"li\",[e(\"code\",[n._v(\"$emit\")]),n._v(\"需要传入一个参数\"),e(\"code\",[n._v(\"type\")]),n._v(\"，用来确定需要触发哪个事件\")]),n._v(\" \"),e(\"li\",[n._v(\"执行缓存列表里面的回调函数，需要对这个列表做一个循环，然后执行回调函数\")])]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[n._v(\"class EventEmitter {\\n  constructor() {\\n    this.message = {} // 消息队列（缓存列表）\\n\\n  }\\n\\n  /** $on:向消息队列添加内容\\n   * @params {*} type:事件名\\n   * @params {*} callback:回调函数\\n   **/\\n  $on(type, callback) {\\n    // 判断是否有事件类型这个属性\\n    if (!this.message[type]) {\\n      // 没有的话，初始化一个空数组\\n      this.message[type] = [];\\n    }\\n    // 把回调函数放入调度中心中\\n    this.message[type].push(callback)\\n  }\\n  /** $emit:触发发消息队列的对应内容\\n   * @params {*} type:事件名\\n   **/\\n  $emit(type) {\\n    // 判断是否有订阅\\n    if (!this.message[type]) return;\\n    // 循环，然后执行缓存列表中对应事件类型下的所有回调函数\\n    this.message[type].forEach(item => {\\n      item();\\n    })\\n    \\n\\n  }\\n  /** $off:删除消息队列的对应内容\\n   * @params {*} type:事件名\\n   * @params {*} callback:回调函数\\n   **/\\n  $off(type, callback) {\\n    // 判断如果没有type这个事件类型，没有直接return\\n    if (!this.message[type]) return;\\n    // 判断有没有回调函数，没有直接删除整个事件\\n    if (!callback) {\\n      this.message[type] = undefined\\n    }\\n    // 如果有callback，就仅仅删除callback这个消息\\n    this.message[type] = this.message[type].filter(item => item !== callback)\\n\\n  }\\n}\\n\\nfunction fn1() {\\n  console.log(\\\"我是函数fn1\\\")\\n}\\n\\nfunction fn2() {\\n  console.log(\\\"我是函数fn2\\\")\\n}\\n// 使用构造函数创建一个实例\\nconst person1 = new EventEmitter()\\n// 像这个person1委托一些内容\\nperson1.$on('buyPhone', fn1)\\nperson1.$on('buyPhone', fn2)\\nperson1.$emit('buyPhone')\\n\\nconsole.log(\\\"person1====\\\", person1)\\n\")])])]),e(\"p\",[n._v(\"打印出来结果如下\")]),n._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4597395647f4009a8641b79152655c0~tplv-k3u1fbpfcp-watermark.image?\",alt:\"image.png\"}})]),n._v(\" \"),e(\"p\",[n._v(\"发现成功的触发了，哈哈哈哈简单功能基本完成了\")]),n._v(\" \"),e(\"p\",[e(\"a\",{attrs:{href:\"https://code.juejin.cn/pen/7213202715097661501\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"完整代码\"),e(\"OutboundLink\")],1)]),n._v(\" \"),e(\"p\",[e(\"strong\",[n._v(\"参考文章\")])]),n._v(\" \"),e(\"p\",[e(\"a\",{attrs:{href:\"https://juejin.cn/post/7052637219084828680\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"https://juejin.cn/post/7052637219084828680\"),e(\"OutboundLink\")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);","extractedComments":[]}